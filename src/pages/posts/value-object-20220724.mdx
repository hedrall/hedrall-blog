---
slug: "value-object-20220724"
title: "[ドメイン駆動設計]: TypeScriptでのValueObjectの書き方"
date: 2022-07-24
author: hedrall
image: "https://user-images.githubusercontent.com/20538481/180634538-4c6a8197-a811-41f3-8672-56f5e5bcacc7.svg"
tags:
  - typescript
  - architecture
  - ddd
---

![ts-lettermark-blue](https://user-images.githubusercontent.com/20538481/180634538-4c6a8197-a811-41f3-8672-56f5e5bcacc7.svg)

## 概要

ドメイン駆動設計で重要な要素となるValueObjectですが、TypeScriptでは`class`でprimitiveが宣言できないなど言語特性的にに工夫が必要な点があり長い間悩んできました。しかしながら、最近になってようやく効果的なパターンが何種類か定まってきましたので、本記事では下記のパターンに関して私が実践しているValueObjectの書き方をご紹介させて頂きます。

アジェンダ

1. プロパティが1つのValueObject
2. プロパティが2つ以上のValueObject
3. インスタンスレベルのvalidationロジックを持った、ValueObject

## 1. プロパティが1つのValueObject

SingleValueな値オブジェクトをTypeScriptで宣言する場合に皆さんはどの様にしますか？
最も単純なパターンだとclassを利用する方法がありますが、以下の様な問題点があります。


例)

```typescript
class EmailAddress {
  value: string;
  constructor (value) { this.value = value; }
}
const emailAddress = new EmailAddress('test@test.com');
```

問題点

1. 毎回 emailAddress.value で値を取り出す必要がある
2. `JSON.stringify`した結果が、`{ "value" : "test@test.com" }`になる

2に関しては、`toJSON`メソッドを実装する事で対処可能ですが(下記)、
1に関しては、TypeScriptではプリミティブな型をclassで宣言ができないため、対処することができません。

```typescript
// toJSONを利用する例
class EmailAddress {
  value: string;
  constructor (value) { this.value = value; }
  
  toJSON(){
    return this.value;
  }
}
const emailAddress = new EmailAddress('test@test.com');
console.log(JSON.stringify(emailAddress)); // => "test@test.com"
```

そこで、[コンパニオンオブジェクト](https://typescriptbook.jp/tips/companion-object) を活用する事ができます。
コンパニオンオブジェクトを知らない方に簡単に説明すると、classでいう**型**と**static method**を個別に宣言する事ができる機能です。

以下は、携帯電話番号の例として、コンパニオンオブジェクトを利用したValueObjectの実装を示します。

```typescript
type CellPhoneNumber = `${number}-${number}-${number}`;
// 型と同名で宣言
const CellPhoneNumber = {
  // ファクトリ関数
  create: (value: string): CellPhoneNumber => {
    if (!/^[0-9]{3}-[0-9]{4}-[0-9]{4}$/.test(value)) {
      throw new Error(`携帯電話番号の形式が正しくありません。`);
    }
    return value as CellPhoneNumber;
  }
}
```

こうする事でclassを利用した際の問題点を解消する事ができます。

```typescript
const num1: CellPhoneNumber = CellPhoneNumber.create('000-0000-0000');
const num2: string = num1; // OK
console.log(JSON.stringify(num1)); // => "000-0000-0000"
```

この様に、`num1`は通常のstring型と同様に利用する事ができます。

更に、上記の例ではファクトリの利用を強制する事ができておらず、不正な文字列を代入する事ができてしまいます。

```typescript
// 不正なStringが代入可能
const num: CellPhoneNumber = '080-00000000000000000000000000-0000000';
```

そのため、[type-fest](https://github.com/sindresorhus/type-fest) などに実装されている [Opaque型](https://github.com/sindresorhus/type-fest/blob/main/source/opaque.d.ts) などを利用する事ができます。`Opaque`型を簡単に説明すると、同じ内容の型でも識別子(token)に従って別の型として区別するための型で、以下のような特性があります。

```typescript
type T1 = Opaque<string, 'hoge' /* <- token */ >;
type T2 = Opaque<string, 'fuga'>;

// NG!
const v1: T1 = 'hoge';
// NG!
const v2: T2 = '' as T1;
```

これを利用する事で、ファクトリの利用を基本的には強制する事ができます。

```typescript
import { Opaque } from 'type-fest';

// Opaque型を利用する
type CellPhoneNumber = Opaque<`${number}-${number}-${number}`, 'CellPhoneNumber'>;
const CellPhoneNumber = {
  create: (value: string): CellPhoneNumber => {
    if (!/^[0-9]{3}-[0-9]{4}-[0-9]{4}$/.test(value)) {
      throw new Error(`携帯電話番号の形式が正しくありません。`);
    }
    return value as CellPhoneNumber;
  }
}

// NG!
const num1: CellPhoneNumber = '080-00000000000000000000000000-0000000';
// OK!
const num2: CellPhoneNumber = CellPhoneNumber.create('080-0000-0000');
```

以上で、SingleValueな値オブジェクトを宣言する事ができました。

## 2. プロパティが2つ以上のValueObject

この場合は、1で掲げた問題点が無いため、普通にclassでValueObjectを宣言して特段問題がありません。

```typescript
type Unit = '円' | 'ドル';
class Price {
  unit: Unit;
  amount: number;
  
  constructor (props: Price) {
    this.unit = props.unit;
    this.amount = props.amount;
  }
}
```

しかし、getter/setterやメソッドを生やす場合は注意が必要です。

```typescript
class Price {
  unit: Unit;
  amount: number;

  // ドルを円に変換する関数
  get changeDollarToYen(): Price {
    // Property 'changeDollarToYen' is missing in type
    return new Price({
      unit: '円',
      amount: this.amount * 100 /*適当*/,
    });
  }

  constructor (props: Price) {
    this.unit = props.unit;
    this.amount = props.amount;
  }
}
```

ドルを円に変換する関数を定義してみましたが、戻り値を作成する所でエラーが発生します。getter/setterやメソッドはクラスの型に含まれるので、newするときは`changeDollarToYen`も引数に渡さなくてはならない状態になっています。

これを避けるため、面倒ですがPropの定義をベースクラスに別途切り分ける方法がおすすめです。

```typescript
abstract class PriceBase {
  unit: Unit;
  amount: number;

  constructor (props: PriceBase) {
    this.unit = props.unit;
    this.amount = props.amount;
  }
}

class Price extends PriceBase {
  // ドルを円に変換する関数
  get changeDollarToYen(): Price {
    return new Price({
      unit: '円',
      amount: this.amount * 100 /*適当*/,
    });
  }

  constructor (props: PriceBase) { 
    super(props) 
  }
}
```

ベースクラスは`abstract`にしておくと、直接利用する事ができない事も表現できます。ちなみに、[aws-cdk](https://github.com/aws/aws-cdk/blob/main/docs/DESIGN_GUIDELINES.md#abstract-base) のデザインが参考になっています。
これで、accessorメソッドを持ったMultiple ValuesなValueObjectを定義する事ができます。

## 3. インスタンスレベルのvalidationロジックを持った、ValueObject

まず表題の意味ですが、まずObjectの値のValidationには３種類の階層が存在します。

1. プロパティレベル
2. インスタンスレベル
3. インスタンス間レベル

> 実践ドメイン駆動設計を参考

1は個別のプロパティへの制約で、上記で説明した携帯電話番号などが例になりますが、`/^[0-9]{3}-[0-9]{4}-[0-9]{4}$/`という正規表現に従わなくてはなりません。
今回テーマにする2は複数のプロパティ間で発生する制約に関してです。

少々無理やりな例で恐縮ですが、あるスーパーマーケットの商品が以下のようになっているとします。

![image](https://user-images.githubusercontent.com/20538481/180335259-5a0e1fc4-ebce-4ee2-96e5-b979532daba0.png)

このスーパーでは上図の通り、トマト・キュウリ・アイスクリームの3種類の食品を販売しています。この内、冷凍食品には賞味期限がないとします。
ここで、食品を表す`Food`をValueObjectとして定義したいと思います。

まずは、classを用いて単純に記述すると以下の様になると思います。

```typescript
type FoodCategory = '野菜' | '魚' | '冷凍';
class Food {
  category: FoodCategory;
  // 賞味期限
  appreciationPeriod?: Date;
  
  constructor (props: Food) {
    this.category = props.category;
    this.appreciationPeriod = props.appreciationPeriod;
  }
}
```

ただし、`category`によって賞味期限のあるなしが変わるため、validationロジックを追加する必要があります。

```typescript
class Food {
  category: FoodCategory;
  // 賞味期限
  appreciationPeriod?: Date;
  
  constructor (props: Food) {
    if (this.validate(props)) {
      throw new Error('値が不正です。');
    }
    this.category = props.category;
    this.appreciationPeriod = props.appreciationPeriod;
  }

  validate(props: Food): boolean {
    switch ( this.category ) {
      case '野菜':
      case '魚':
        return !!this.appreciationPeriod;
      case '冷凍':
        return !this.appreciationPeriod;
    }
  }
}
```

これで、安全に`Food`を生成できるようになりましたが、実は値を利用する際には少し不便さを感じます。

```typescript
declare const tomato: Food;

if (tomato.category === '野菜') {
  const now = new Date();
  
  // 賞味期限内か確認 
  // ↓ TS2532: Object is possibly 'undefined'.
  if (tomato.appreciationPeriod > now) { ... }
}
```

`tomato.category === '野菜'`で条件分岐をしたのにも関わらず、クラス間のプロパティには型の絞り込みが効きません。

そこで、class記法ではなくコンパニオンオブジェクトを利用する事ができます。更に、namespaceを組み合わせると型をまとめるのに便利です。

> 参考: [TypeScriptのnamespaceは非推奨ではない](https://qiita.com/yuki153/items/a51878ad6a1ce913af48)

```typescript
namespace Food {
  export type General = {
    category: Exclude<FoodCategory, '冷凍'>;
    appreciationPeriod: Date;
  }
  export type Cold = {
    category: Extract<FoodCategory, '冷凍'>;
    appreciationPeriod: Date;
  }
}
type Food = Food.General | Food.Cold;
const Food = {
  create(props: Food): Food {
    const validate = () => {
      switch ( props.category ) {
        case '野菜':
        case '魚':
          return !!props.appreciationPeriod;
        case '冷凍':
          return !props.appreciationPeriod;
      }
    };
    if (!validate()) throw new Error('値が不正です。');

    return props as Food;
  }
}
```

少々定義が長くなりましたが、この記法にはいくつか利点があります。

まず、先ほどのクラス定義と比べて、`GeneralFood`, `ColdFood`を明確に定義しているので、どんなFoodの種類が存在するのかがわかりやすくなりました。もちろん、`validation`の中身を読んでいけばロジックから逆算する事ことは可能なのですが、明示的に型定義されていることによって、よりドキュメントとしての価値が向上しています。

また、先程問題になっていた型の絞り込みが効くようになっています。

```typescript
declare const tomato: Food;

if (tomato.category === '野菜') {
  const now = new Date();

  // 賞味期限内か確認
  // OK!!
  if (tomato.appreciationPeriod > now) { ... }
}
```

より絞り込みを簡単にするため、`TypeGuard`を宣言すると便利です。

```typescript
const Food = {
  create(props: Food): Food { /* ... */},
  guards: {
    isGeneral(food: Food): food is Food.General {
      return food.category !== '冷凍';
    },
    isIce(food: Food): food is Food.Cold {
      return food.category === '冷凍';
    },
  }
}

if (Food.guards.isGeneral(tomato)) {
  const now = new Date();

  // 賞味期限内か確認
  // OK!!
  if (tomato.appreciationPeriod > now) { ... }
}
```

以上で、インスタンスのプロパティ間に組み合わせの制約が有る場合のValueObjectを定義する事ができました。

## まとめ

冒頭で紹介した3パターンに関して具体的な実装方法をご紹介しました。まだまだ考慮するべき点はたくさんあるかと思いますが、一定の価値のあるパターンがまとまったと思い、公開させて頂きました。
他に良い方法や未解決な問題点などあれば別途調査してみたいと思いますので、コメントなどもいただけると幸いです。

長文になりましたが、ここまで読んで頂きありがとうございました q😄
